---
created: 2025-11-25
tags:
  - leetcode
  - todo-review
  - "#string"
problem_link: https://leetcode.com/problems/longest-word-in-dictionary/description/
difficulty: medium
---

# [720] 

# Examples
**Example 1:**

**Input:** words = ["w","wo","wor","worl","world"]
**Output:** "world"
**Explanation:** The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".

**Example 2:**

**Input:** words = ["a","banana","app","appl","ap","apply","apple"]
**Output:** "apple"
**Explanation:** Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".

# Whiteboard
## SOL: Sort + Set 
- First, sort the words A-->Z
	- a
	- b
	- ap
	- app
	- appl
	- apple
	- apply
	- banana
- ~~Add 1-char words: `a, b`~~
- Add empty string to **map** --> every 1 char words can be formed by empty string
- With every words, check: 
	- if **exists** `s[:len-1]`  --> add to set & set as result 
	- `ap`: `a` existed --> add ap to set 
3.  **Complexity:** Time $O(NlogN)$ | Space $O(N)$
## ğŸ§  The "Aha!" Moment
- A word can only be built if the previous part is existed
There are two solutions to this problem:
- **1: (Sort + Set):** 
	- Time:  $O(N \cdot L \cdot \log N)$
- **2: Trie (Prefix Tree):** 
	- Time: $O(N \cdot L)$
--> While the Trie is theoretically faster (linear time, no sorting), [1] is preferred because:

1. **Simplicity:** It takes ~12 lines of code vs ~50 lines for a Trie.
    
2. **Locality:** Sorting and Iterating arrays is extremely cache-friendly for modern CPUs.
    
3. **Tie-Breaking:** Sorting handles the "lexicographically smallest" requirement automatically. In a Trie, you have to carefully traverse children in alphabetical order (a->z).

> [!tip] Key Constraint
> ## ğŸ“ Solution Strategy
4.  **Step 1:** ...
5.  **Step 2:** ...
6.  **Complexity:** Time $O(\dots)$ | Space $O(\dots)$

## ğŸ’» Code (Go)
```go
```