---
created: 2025-11-22
tags:
  - leetcode
  - medium
  - brainteaser
  - math
  - prefix-sum
  - sorting
problem_link: https://leetcode.com/problems/movement-of-robots/description/
---

# [2731] Movement of Robots

## üß† The "Aha!" Moment
The core trick is **Identity Equivalence**. 

When two robots collide and reverse direction, it is mathematically identical to them **passing through each other** (like ghosts) without changing direction.
- Since we only care about the *sum of distances* (not which robot is where), the set of final positions is the same in both scenarios.
- **Key Action:** Ignore the collision logic entirely. Just calculate `finalPos = initialPos + (direction * time)`.

> [!info] Visual Proof
> A robot at `0` moving `R` and a robot at `2` moving `L` (dist=2):
> - **Collision:** They meet at `1`, bounce, and end at `0` (L) and `2` (R). Positions: `{0, 2}`.
> - **Ghost:** They pass through. End at `2` (R) and `0` (L). Positions: `{2, 0}`.
> - The **set** of positions is identical.

## üìù Solution Strategy
1.  **Simulation:** Update all positions as if no collisions occur.
2.  **Sorting:** Sort the final positions array. This is required to calculate pairwise distances efficiently.
3.  **Math (Sum of Differences):** Instead of $O(N^2)$ brute force, use the **Contribution Technique**.
    For a sorted array, the distance between all pairs is:
    $$\sum_{i=0}^{n-1} (i \cdot A[i] - (n-1-i) \cdot A[i])$$
    *Essentially: How many people are to my left (I'm bigger than them) minus how many are to my right (I'm smaller than them).*

## üíª Code (Go)
```go
func sumDistance(nums []int, s string, d int) int {
    const mod = 1e9 + 7
    n := len(nums)

    // 1. Ghost Logic: Update positions ignoring collisions
    for i := 0; i < n; i++ {
        if s[i] == 'R' {
            nums[i] += d
        } else {
            nums[i] -= d
        }
    }

    // 2. Sort to enable O(N) calculation
    sort.Ints(nums)

    // 3. Calculate sum of pairwise differences
    sum := 0
    for i := 0; i < n; i++ {
        // Contribution = (Elements to left * val) - (Elements to right * val)
        val := nums[i]
        leftCount := i
        rightCount := n - 1 - i
        
        // Be careful with Modulo on negative numbers
        term := (val % mod) * ((leftCount - rightCount) % mod)
        sum = (sum + term) % mod
    }

    if sum < 0 { sum += mod }
    return sum
}