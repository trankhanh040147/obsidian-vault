
# Sol 1: Base62 conversion
 **The Best LeetCode Solution (Counter + Base62)**

While the Random String approach works, the **mathematically "best"** solution is **Auto-Increment ID + Base62 Encoding**.

**Why is it the best?**

1.  **Determinism:** Input ID `100` always becomes `bM`. No randomness.
2.  **No Collisions:** Since every ID is unique, every Short URL is guaranteed to be unique. You never need to check "does this exist already?"
3.  **Shortest Possible Length:**
      * With Base62 (a-z, A-Z, 0-9), a 6-character string can store $62^6$ combinations ($\approx 56$ billion URLs).
      * A simple integer counter is extremely memory efficient.

#### The Go Solution

```go
import "strings"

type Codec struct {
    urls map[int]string
    id   int
}

func Constructor() Codec {
    return Codec{urls: make(map[int]string), id: 0}
}

// 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
const chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

// Encodes a URL to a shortened URL.
func (this *Codec) encode(longUrl string) string {
    this.id++
    this.urls[this.id] = longUrl
    
    // Convert Integer ID to Base62 String
    num := this.id
    sb := strings.Builder{}
    for num > 0 {
        remainder := num % 62
        sb.WriteByte(chars[remainder])
        num /= 62
    }
    return "http://tinyurl.com/" + sb.String()
}

// Decodes a shortened URL to its original URL.
func (this *Codec) decode(shortUrl string) string {
    code := strings.Replace(shortUrl, "http://tinyurl.com/", "", 1)
    
    // Convert Base62 String back to Integer ID
    id := 0
    for i := len(code) - 1; i >= 0; i-- {
        val := strings.IndexByte(chars, code[i])
        id = id*62 + val
    }
    return this.urls[id]
}
```

-----

### Part 2: How Real Systems (TinyURL, Bitly) Do It

In the real world, you cannot use a single Go `map` because it disappears if the server crashes, and it doesn't fit in memory (RAM).

Real systems use a **Distributed Key Generation Service (KGS)**.

#### 1\. The Problem with Auto-Increment

If you just use a database like MySQL with `AUTO_INCREMENT`:

  * It becomes a bottleneck (Single Point of Failure).
  * It is easy for hackers to guess URLs. If they see `tinyurl.com/100`, they know the next one is `101`.

#### 2\. The Solution: Pre-Generated Keys (KGS)

This is the standard System Design Interview answer.

Instead of generating keys *when* a user clicks "Shorten", they generate them **days/weeks in advance**.

1.  **Offline Generation:** A separate "Key Generation Service" runs in the background. It generates random 6-character strings (e.g., `abc001`, `abc002`) and stores them in a **"Unused Keys" Table** in the database.
2.  **Assigning Keys:** When a user requests a short URL:
      * The Web Server asks the KGS: "Give me a key."
      * The KGS takes the top key from the "Unused" table, moves it to the "Used" table, and gives it to the server.
      * The server saves `Map[Key] = LongURL`.

**Why is this approach superior?**

  * **Zero Latency:** No calculating hashes or converting Base62 while the user waits. The key is already ready.
  * **No Collisions:** Because the keys were generated and checked offline, we are 100% sure they are unique before we even give them to a user.
  * **Security:** The keys appear random (not sequential), so users can't guess the next URL.