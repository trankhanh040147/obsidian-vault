**Input:** nums = [1,2,1,4,3], left = 2, right = 3
[ 1,2 ]
[ 1,2,1 ]
[ 2 ]
[ 2,1 ]
[ 3 ]

**Inclusion-Exclusion:**
S[2->3] = S[3] - S[1]
S(i): Total subarrays with max <= i

S[3] = count[1,2,1] + count[3] = 3(3+1)/2 + 1 = 7
S[1] = 2
--> result = 5

Input: nums = [2,9,2,5,6], left = 2, right = 8
[ 2 ]
[ 2 ]
[ 2,5]
[ 2,5,6 ]
[ 5,6 ]
[ 5 ]
[ 6 ]


[73,55,36,5,55,14,9,7,72,52], left = 32, right = 69

55
55,36
55,36,5 
55,36,55 
55,36,55,14
55,36,55,14,9
55,36,55,14,9,7

36
36,5 
36,55 
36,55,14
36,55,14,9
36,55,14,9,7

55 
55,14
55,14,9
55,14,9,7

52

**Missing:**
5,55
5,55,14
5,55,14,9
5,55,14,9,7

---
# Sol 1: Brute force nested loop (wrong)
```go
func numSubarrayBoundedMax(nums []int, left int, right int) int {
	if len(nums) == 0 {
		return 0
	}
	res := 0
	i := 0
	maxNum := 0
	for i < len(nums) {
		j := i
		maxNum = nums[j]
		for j < len(nums) {
			if nums[j] > maxNum {
				maxNum = nums[j]
			}
			if maxNum < left || maxNum > right {
				break
			}
			res++
			j++
		}
		i++
	}
	return res
}

```
--> This is wrong because it count subarrays that starts with a valid num. Mean while *5,55* in **Missing** is still valid 

---
# Sol 2: Inclusion-Exclusion principle 

**RESULT = (Total subarrays with max <= `right`) - (Total subarrays with max <= `left - 1`)**

