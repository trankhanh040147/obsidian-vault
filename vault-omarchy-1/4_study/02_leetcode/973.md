https://leetcode.com/problems/k-closest-points-to-origin/description/

- INPUT: `points [][2]int, k int`
- OUTPUT: `[][2]int`
- CONSTRAINTS: 
	- 1 <= k <= n <= 10^4 (n = points.length)
	- -10^4 <= x, y <= 10^4 
**Sol 1: Sorting**d
- Sort `points` by Euclidean distance
- Time complexity: O(NlogN) = 10^5
- Space: O(n)
**Sol 2: Priority Queue (Min Heap)**: 
- We need a structure that can: 
	- Get and remove smallest element: O(1) 
	- Append a new element and can maintain the same sort order of the structure
- Time complexity: O(NlogN)
- Space: O(n)

**Min Heap from unsorted array**
- arr = [0, 1, 2, 3, 4]
-> min heap structure: 
- last parent: 5/2 - 1 = 1 
```
	  0
	 / \
	1   2
	/ \
	3   4
```

- arr = [18, 5, 3 , 9, 1, 2]
```
	   1
	 /   \
	5     2
   / \    /
  9  18  3
```
---
- [ ] How to pop ?
- [ ] Testing ?
- [ ] Complexity ?

**Pop from root**
_ShiftUp_(left|right)

- arr = [1, 2, 5 , 9, 18, 3]
```
	   1
	 /   \
	2     5
   / \    /
  9  18  3
```
- *Pop()* = 1
	- *Swap(First, Last) --> 1 <--> 3*
	- *Shrink*: `arr = arr[:len()-1]`
```
	   3
	 /   \
	2     5
   / \   
  9  18  
```
- *ShiftDown(3)*
```
	   2
	 /   \
	3     5
   / \   
  9  18  
```

---
**Sol 3: Top K pattern (Max Heap)**: 
- Why Max Heap ?
	If you use a **Min-Heap**:
	
	- You must calculate the distance for all N points.
	
	- You push all N points onto the Min-Heap. (This takes O(NlogN) time).
	
	- You then pop() the K smallest elements. (This takes O(KlogN) time).
	
	This works, but its total time is **O(NlogN)**, which is the same as just sorting the whole list. You're doing a lot of extra work by keeping all N items organized.

- How it works ?
This method's goal is to maintain a heap that only holds the K best-so-far.

1. Create a Max-Heap but limit its size to K.

2. Iterate through all N points:

3. Get the point's distance.

4. If the heap has fewer than K elements, just push the new point (and its distance).

5. If the heap is full (K elements), compare the new point's distance to the root of the Max-Heap.

6. The root of a Max-Heap is the farthest point (the largest distance) we're currently holding.

7. If the new point is closer (smaller distance) than the root, it deserves to be in our "Top K." So, we pop the farthest point and push the new, closer point.

8. If the new point is farther away, we just ignore it.

9. After checking all N points, your heap will contain exactly the K closest points.

**Example**
**1:**
- arr = [3, 5, 9 , 18, 1, 2], k = 5
```
	   9
	 /   \
	3     5
   / \    
  ?  ?  
```