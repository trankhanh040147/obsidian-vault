https://leetcode.com/problems/k-closest-points-to-origin/description/

- INPUT: `points [][2]int, k int`
- OUTPUT: `[][2]int`
- CONSTRAINTS: 
	- 1 <= k <= n <= 10^4 (n = points.length)
	- -10^4 <= x, y <= 10^4 
**Sol 1: Sorting**
- Sort `points` by Euclidean distance
- Time complexity: O(NlogN) = 10^5
- Space: O(n)
**Sol 2: Priority Queue (Min Heap)**: 
- We need a structure that can: 
	- Get and remove smallest element: O(1) 
	- Append a new element and can maintain the same sort order of the structure
- Time complexity: O(NlogN)
- Space: O(n)

**Min Heap from unsorted array**
- arr = [0, 1, 2, 3, 4]
-> min heap structure: 
- last parent: 5/2 - 1 = 1 
```
	  0
	 / \
	1   2
	/ \
	3   4
```

- arr = [18, 5, 3 , 9, 1, 2]
```
	   1
	 /   \
	5     2
   / \    /
  9  18  3
```
---
- [ ] How to pop ?
- [ ] Testing ?
- [ ] Complexity ?

**Pop from root**
_ShiftUp_(left|right)

- arr = [1, 2, 5 , 9, 18, 3]
```
	   1
	 /   \
	2     5
   / \    /
  9  18  3
```
- *Pop()* = 1
	- *Swap(First, Last) --> 1 <--> 3*
	- *Shrink*: `arr = arr[:len()-1]`
```
	   3
	 /   \
	2     5
   / \   
  9  18  
```
- *ShiftDown(3)*
```
	   2
	 /   \
	3     5
   / \   
  9  18  
```