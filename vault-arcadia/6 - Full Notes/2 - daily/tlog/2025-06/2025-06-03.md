- **Nhân sự**: *Kenny*
* **Việc đã thực hiện**:    	
	- Check lỗi dịch vụ QChat
	- Triển khai dịch vụ Trợ lý luật
	- API training model DVC Admin (70%)
* **Việc hôm nay**:
	- Hoàn thành API training model DVC Admin
	- Cập nhật reference_files cho Trợ lý luật
- **Khó khăn**:
---
#tla-bridge 
- [x] report tháng 
- [x] update doc CMD Stop
- [x] test bridge DEV + check log APM
- [ ] test: Cmd Stop (dev)
- [ ] handle: STOP with sequence <= 1 && text_counter < 1

#qchat 
- [ ] test: timeout 5p

#tla-api 
- [ ] check agent.Do
#dr 
- [ ] SyncIndexesByCollections
	- [ ] FEAT: handle case conflict name
---
#docs #go 
- [ ] [Go Concurrency Patterns: Pipelines and cancellation - The Go Programming Language](https://go.dev/blog/pipelines)
#news 

#mongo 
- [ ] how index in mongo store? On mem or on disk? 
---
#blog #quanghoang
- [ ] [#1 - Thiết kế KV database như thế nào? Bài học từ Bitcask](https://quanghoang.substack.com/p/50-days-of-sd-bitcask)
	- [x] what is a key-value database ? what is it pro/con compare to a regular database ?
		A key-value database is a type of NoSQL database that stores data as simple pairs: a key and its associated value. It’s like a giant dictionary or hashmap where you look up data by a unique key.
	- [x] where data is saved ? --> HHD, SSD, in-memory, RAM
	- [x] where Bitcask store data? 
	      On persitent disk storage (HDD or SSD)
	- [x] Bitcask uses append-only log files (called data files) stored in a directory on the filesystem
	- [x] Alongside data files, Bitcask keeps hint files and an in-memory hash index for fast key lookup.
	- [x] how Bitcask builds index ? 
	--> On startup, Bitcask reads the log files and buils the in-mem index to map keys to their position in those files
	- [x] Why index is stored in-memory, not on disk ? And it need to builds index every time restarting ?
		- **Speed:**  
		    The main goal of Bitcask is **ultra-fast key lookups**. Keeping the entire key-to-data-position index in RAM means lookups are just simple hash table lookups — very fast (O(1) time).
		- **Simplicity:**  
		    An in-memory hash table is simpler to implement and maintain than a complex on-disk index structure.
		- **Avoids disk seeks:**  
		    If the index were on disk, every lookup would require a disk read, which slows down performance drastically compared to RAM access.
	- [x] So what happens if the index takes too much spaces, and eat up all memory ?
	      --> It’s originally built for workloads with relatively small key sizes and a manageable number of keys so the index fits comfortably in memory.
	- [x] why Bitcask stored data on append-only files ?
	      --> Appending new data sequentially to the end of a file is very fast and efficient on disks (both HDD and SSD). It avoids costly random writes and disk seeks. (sequential IO)
	- [ ] 

| Storage Type              | Volatility   | Speed           | Persistence | Common Use Cases                    |
| ------------------------- | ------------ | --------------- | ----------- | ----------------------------------- |
| RAM                       | Volatile     | Fastest         | No          | In-memory DB, caching               |
| SSD                       | Non-volatile | Very fast       | Yes         | Primary DB storage                  |
| HDD                       | Non-volatile | Slower          | Yes         | Large storage, archival             |
| NVMe                      | Non-volatile | Faster than SSD | Yes         | High-performance DB storage         |
| Persistent Memory/NVRAM   | Non-volatile | Near RAM speed  | Yes         | Emerging persistent DB storage      |
| Distributed Cloud Storage | Non-volatile | Variable        | Yes         | Scalable, fault-tolerant DB systems |
