- [x] Delete many indexes
- [ ] Usecase: Sync index from model.Index to mongoIndex
	- [ ] util: convert MongoIndex --> model.Index
- [ ] Usecase: CompareIndexes between two collections
	- [ ] Phương pháp check:
		- Check dựa vào names
			- == keys
				- == options
				- != options
			- != keys
				- == options
				- != options			
			- [ ] db1 có index idx01, db2 có index idx02, giống keys, giống options --> Matched
			- [ ] db1 có index idx01, db2 có index02, khác keys --> unmatched
			- [ ] db1 có index idx01, db2 có index02, giống keys, khác options --> unmatched 
			- [ ] db1 có index idx01, db2 ko có idx01: db2 thiếu idx01
		- Check dựa vào keys 
			- != name
				== keys
					== options : matched
					!= options: unmachted
			- [ ] db1 có index idx01 có keys = {k1:v1, k2:v2}, db2 có index idx02 có keys = {k1:v1, k2:v2} --> index matched
	- [ ] Research cách compare indexes giữa 2 collection: https://stackoverflow.com/questions/19446437/compare-indexes-in-two-databases
	- [ ] util: convert MongoIndex --> model.Index
	- [ ] Tạo index \_id_ khi nào ? --> Khi check difference
- [ ] Usecase: get MongoClient from connection
- [ ] Hiển thị thông tin Connection dạng embed (URI, dbName)

- [ ] Self refactor:
	- [ ] Check status các lỗi d
		- [ ] Check shorthand if *err*
	- [ ] ...
---
#mach
- [ ] [tmux] fix MouseDragEnd1Pane
---
**Đã làm**
- Create/Update index: Auto generate name nếu không nhập name
- Hoàn thành api Update/DeleteOne/DeleteMany Index by index id 
- Check conflict khi tạo index với các keys đã tồn tại
- Lưu các options unique, expire --> struct model
- Thông báo cụ thể lỗi khi tạo Index bị conflict --> constrant violated: {index_name}
**Khó khăn**
- Xử lý chưa đủ các edge cases khi input dạng struct, array
**Kế hoạch**
- Kiểm tra sự khác nhau index với 
- Xử lý case xóa các indexes sau khi xóa connection 
- Api: get collections (admin) by connection (có paging, search name), sync indexes (by db, by collection)